//#include <fstream>
#include <vector>
#include <stdlib.h>
#include <iostream>
#include <math.h>
#include <bitset>
#include "pzcmesh.h"
#include <opencv2/opencv.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include "pzmanvector.h"
#include "TPZGeoMeshTools.h"
#include "TPZCompMeshTools.h"
#include "TPZRefPattern.h"
#include "TPZGenGrid2D.h"
#include "TPZVTKGeoMesh.h"
#include "pzvec.h"
//#include "TPZEigenSolver"
//#include <gmsh.h>
#include <fstream>
#include "pzstepsolver.h"
#include "TPZMaterial.h"
#include "TPZDarcyFlow.h"
#include "TPZLinearAnalysis.h"
#include "TPZExtendGridDimension.h"
#include "pzvisualmatrix.h"
//#include "TestVTK3D.h"
using namespace cv;
using namespace std;
//FUNCION PARA CREAR UNA MATRIZ DE ARCHIVO BINARIO .RAW
TPZVec<TPZFMatrix<double>> create_raw_Vecmatrix(std::string rutaArchivo, int filas, int columnas, int layers){
    std::ifstream file(rutaArchivo, std::ios::binary | std::ios::ate);
    TPZFMatrix<double> matrix(filas,columnas);
    TPZVec<TPZFMatrix<double>> Vectormatrix(layers);
//    int layers=3;
    if (file.is_open()) {
        std::streamsize size = file.tellg();
        file.seekg(0, std::ios::beg);

        std::vector<char> buffer(size);
        file.read(buffer.data(), size);

        int count = 0;
        for(int lay=0;lay < layers;lay++){
        for(int i = 0; i < filas; i++) {
            for(int j = 0; j <columnas ; ++j) {
                if(count >= size) break;
                matrix(i,j) = buffer[count];
                count++;
            }
        }Vectormatrix[lay]=matrix;
        }
    } else {
        std::cout << "Unable to open file";
    }

    return Vectormatrix;
}


//CODIGO PARA CREAR VTK A PARTIR DE ARCHIVO .RAW
void VisualMatrix3DVTK(TPZVec<TPZFMatrix<double>> & matrixVector, const std::string &outfilename)
{
    const int nelz=matrixVector.size();
    TPZFMatrix<double> & matrix1 = matrixVector[0];
    const int nelx = matrix1.Cols();
    const int nely = matrix1.Rows();
    const int neltotal = nelx * nely;
    int i,j;
    
    ofstream out(outfilename.c_str());
    out << "# vtk DataFile Version 3.0\n";
    out << "Generated by PZ\n";
    out << "ASCII\n";
    out << "DATASET RECTILINEAR_GRID\n";
    out << "DIMENSIONS " << (nelx+1) << " " <<  (nely+1) << " " << (nelz+1) <<"\n";
    out << "X_COORDINATES " << nelx+1 << " float\n";
    for (i=0; i<=nelx; i++) {
            out << i << " ";
    }
    out << std::endl;
    out << "Y_COORDINATES " << nely+1 << " float\n";
    for (j=0; j<=nely; j++) {
        out << j << " ";
    }
    out << std::endl;
    out << "Z_COORDINATES " << nelz+1 << " float\n";
    for (int k=0; k<=nelz; k++) {
        out << k << " ";
    }
    out << std::endl;
    out << "CELL_DATA " << nelx*nely*nelz << std::endl;
    out << "SCALARS mat_value float 1\n";
    out << "LOOKUP_TABLE default\n";
    for(int k = 0; k < matrixVector.size(); k++)
    {
        
        TPZFMatrix<double> & matrix = matrixVector[k];
        for (j=0; j<nely; j++) {
            for (i=0;i<nelx;i++) {
                out << matrix(j,i) << std::endl;
                }
        }float avance=static_cast<float>(k+1)/nelz;
        std::cout<<"Avance: "<<(avance)*100<<"%"<<std::endl;
        }
}

//CODIGO PRINCIPAL
int main (){
    std::string ImagenRaw="/Users/victorvillegassalabarria/Downloads/ImagesICPSC2015/Bentheimer_1000c_3p0035um.raw";
    int layers=100;
    int rows=676;
    int cols=616;
    TPZVec<TPZFMatrix<double>> VecOfMat=create_raw_Vecmatrix(ImagenRaw, rows, cols, layers);
//    std::cout<<VecOfMat[0]<<std::endl;
    std::string outfilename ="RAWTestBentheimer.vtk";
    VisualMatrix3DVTK(VecOfMat, outfilename);
  
    
    return 0;
}


