//#include <fstream>
#include <vector>
#include <stdlib.h>
#include <iostream>
#include <math.h>
#include <bitset>
#include "pzcmesh.h"
#include <opencv2/opencv.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include "pzmanvector.h"
#include "TPZGeoMeshTools.h"
#include "TPZCompMeshTools.h"
#include "TPZRefPattern.h"
#include "TPZGenGrid2D.h"
#include "TPZVTKGeoMesh.h"
#include "pzvec.h"
//#include "TPZEigenSolver"
#include <fstream>
#include "pzstepsolver.h"
#include "TPZMaterial.h"
#include "DarcyFlow/TPZDarcyFlow.h"
#include "TPZLinearAnalysis.h"
#include "TPZExtendGridDimension.h"
#include "pzvisualmatrix.h"
#include "EditImage.h"
//#include "TestVTK3D.h"
using namespace cv;
using namespace std;
//FUNCION PARA CREAR UNA MATRIZ DE ARCHIVO BINARIO .RAW
TPZVec<TPZFMatrix<double>> create_raw_Vecmatrix(std::string rutaArchivo, int filas, int columnas, int layers){
    std::ifstream file(rutaArchivo, std::ios::binary | std::ios::ate);
    TPZFMatrix<double> matrix(filas,columnas);
    TPZVec<TPZFMatrix<double>> Vectormatrix(layers);
//    int layers=3;
    if (file.is_open()) {
        std::streamsize size = file.tellg();
        file.seekg(0, std::ios::beg);

        std::vector<char> buffer(size);
        file.read(buffer.data(), size);

        int count = 0;
        for(int lay=0;lay < layers;lay++){
        for(int i = 0; i < filas; i++) {
            for(int j = 0; j <columnas ; ++j) {
                if(count >= size) break;
                matrix(i,j) = buffer[count];
                count++;
            }
        }Vectormatrix[lay]=matrix;
        }
    } else {
        std::cout << "Unable to open file";
    }

    return Vectormatrix;
}


//CODIGO PARA CREAR VTK A PARTIR DE ARCHIVO .RAW
void VisualMatrix3DVTK(TPZVec<TPZFMatrix<double>> & matrixVector, const std::string &outfilename)
{
    const int nelz = matrixVector.size();
    TPZFMatrix<double> & matrix1 = matrixVector[0];
    const int nelx = matrix1.Cols();
    const int nely = matrix1.Rows();
    const int neltotal = nelx * nely;
    int i,j;
    
    ofstream out(outfilename.c_str());
    out << "# vtk DataFile Version 3.0\n";
    out << "Generated by PZ\n";
    out << "ASCII\n";
    out << "DATASET RECTILINEAR_GRID\n";
    out << "DIMENSIONS " << (nelx+1) << " " <<  (nely+1) << " " << (nelz+1) <<"\n";
    out << "X_COORDINATES " << nelx+1 << " float\n";
    for (i=0; i<=nelx; i++) {
            out << i << " ";
    }
    out << std::endl;
    out << "Y_COORDINATES " << nely+1 << " float\n";
    for (j=0; j<=nely; j++) {
        out << j << " ";
    }
    out << std::endl;
    out << "Z_COORDINATES " << nelz+1 << " float\n";
    for (int k=0; k<=nelz; k++) {
        out << k << " ";
    }
    out << std::endl;
    out << "CELL_DATA " << nelx*nely*nelz << std::endl;
    out << "SCALARS mat_value float 1\n";
    out << "LOOKUP_TABLE default\n";
    for(int k = 0; k < matrixVector.size(); k++)
    {
        
        TPZFMatrix<double> & matrix = matrixVector[k];
        for (j=0; j<nely; j++) {
            for (i=0;i<nelx;i++) {
                out << matrix(j,i) << std::endl;
                }
        }float avance=static_cast<float>(k+1)/nelz;
        std::cout<<"Avance: "<<(avance)*100<<"%"<<std::endl;
        }
}

//CODIGO PARA CREAR VTK A PARTIR DE ARCHIVO .RAW
void VisualMatrix3DVTK(Image3D & image, const std::string &outfilename)
{
    const int nelz = image.Depth();
    const int nelx = image.Height();
    const int nely = image.Width();
    const int neltotal = nelx * nely;
    int i,j;
    
    ofstream out(outfilename.c_str());
    out << "# vtk DataFile Version 3.0\n";
    out << "Generated by PZ\n";
    out << "ASCII\n";
    out << "DATASET RECTILINEAR_GRID\n";
    out << "DIMENSIONS " << (nelx+1) << " " <<  (nely+1) << " " << (nelz+1) <<"\n";
    out << "X_COORDINATES " << nelx+1 << " float\n";
    for (i=0; i<=nelx; i++) {
            out << i << " ";
    }
    out << std::endl;
    out << "Y_COORDINATES " << nely+1 << " float\n";
    for (j=0; j<=nely; j++) {
        out << j << " ";
    }
    out << std::endl;
    out << "Z_COORDINATES " << nelz+1 << " float\n";
    for (int k=0; k<=nelz; k++) {
        out << k << " ";
    }
    out << std::endl;
    out << "CELL_DATA " << nelx*nely*nelz << std::endl;
    out << "SCALARS " << image.VarName() << " float 1\n";
    out << "LOOKUP_TABLE default\n";
    for(int k = 0; k < nelz; k++)
    {
        for (j=0; j<nely; j++) {
            for (i=0;i<nelx;i++) {
                out << image.getPixel(k,j,i) << std::endl;
            }
        }
    }
    out << std::endl;
}

//CODIGO PARA CREAR VTK A PARTIR DE ARCHIVO .RAW
void AddDataVTK(Image3D & image, const std::string &outfilename)
{
    const int nelz = image.Depth();
    const int nelx = image.Height();
    const int nely = image.Width();
    const int neltotal = nelx * nely * nelz;
    int i,j;
    //ofstream out(outfilename.c_str(),std::ios::app);
    ofstream out(outfilename.c_str());
    out << "# vtk DataFile Version 3.0\n";
    out << "Generated by PZ\n";
    out << "ASCII\n";
    out << "DATASET RECTILINEAR_GRID\n";
    out << "DIMENSIONS " << (nelx+1) << " " <<  (nely+1) << " " << (nelz+1) <<"\n";
    out << "X_COORDINATES " << nelx+1 << " float\n";
    for (i=0; i<=nelx; i++) {
            out << i << " ";
    }
    out << std::endl;
    out << "Y_COORDINATES " << nely+1 << " float\n";
    for (j=0; j<=nely; j++) {
        out << j << " ";
    }
    out << std::endl;
    out << "Z_COORDINATES " << nelz+1 << " float\n";
    for (int k=0; k<=nelz; k++) {
        out << k << " ";
    }
    out << std::endl;
    out << "CELL_DATA " << nelx*nely*nelz << std::endl;
    out << "SCALARS " << image.VarName() << " float 1\n";
    out << "LOOKUP_TABLE default\n";
    for(int k = 0; k < nelz; k++) {
        for (int j=0; j<nely; j++) {
            for (int i=0;i<nelx;i++) {
                out << image.getPixel(k,j,i) << std::endl;
            }
        }
    }
    out << std::endl;
}

int mainfake();
int main() {
    return mainfake();
}
//CODIGO PRINCIPAL
int mainfake (){
//    std::string ImagenRaw="Sample_Labels_3D_RAW.raw";
    std::string ImagenRaw="/Users/victorvillegassalabarria/Downloads/Sample_Labels_3D_RAW1.raw";
    int layers=30;
    int rows=676;
    int cols=616;
    TPZVec<TPZFMatrix<double>> VecOfMat=create_raw_Vecmatrix(ImagenRaw, rows, cols, layers);

    Image3D input("pixeldata",VecOfMat);
    Image3D output("objects",input.Depth(), input.Width(), input.Height());
    Image3D ordered("ordered",input.Depth(), input.Width(), input.Height());
    int count = input.identifyObjects(output);
    output.orderObjectsBySize(ordered, count);
    std::cout << count << "\n";
    std::string outfilename ="RAWTest.vtk";
    std::string outfilename1 ="RAWTestoutput.vtk";
    std::string outfilename2 ="RAWTestordered.vtk";

    VisualMatrix3DVTK(input, outfilename);
    std::cout << "adding object data to " << outfilename1 << "\n";
    AddDataVTK(output, outfilename1);
    std::cout << "adding ordered data to " << outfilename2 << "\n";
    AddDataVTK(ordered, outfilename2);
    return 0;
}


